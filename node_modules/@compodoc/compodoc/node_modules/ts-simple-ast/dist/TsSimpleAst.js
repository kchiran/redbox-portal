"use strict";
var __assign = (this && this.__assign)/* istanbul ignore next */ || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __values = (this && this.__values)/* istanbul ignore next */ || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var minimatch_1 = require("minimatch");
var errors = require("./errors");
var utils_1 = require("./utils");
var DefaultFileSystemHost_1 = require("./DefaultFileSystemHost");
var GlobalContainer_1 = require("./GlobalContainer");
/**
 * Compiler wrapper.
 */
var TsSimpleAst = /** @class */ (function () {
    /**
     * Initializes a new instance.
     * @param options - Optional options.
     * @param fileSystem - Optional file system host. Useful for mocking access to the file system.
     */
    function TsSimpleAst(options, fileSystem) {
        if (options === void 0) { options = {}; }
        if (fileSystem === void 0) { fileSystem = new DefaultFileSystemHost_1.DefaultFileSystemHost(); }
        this.fileSystem = fileSystem;
        this.global = new GlobalContainer_1.GlobalContainer(fileSystem, getCompilerOptionsFromOptions(options, fileSystem), true);
        if (options.manipulationSettings != null)
            this.global.manipulationSettings.set(options.manipulationSettings);
    }
    Object.defineProperty(TsSimpleAst.prototype, "manipulationSettings", {
        /** Gets the manipulation settings. */
        get: function () {
            return this.global.manipulationSettings;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add source files based on file globs.
     * @param fileGlobs - File globs to add files based on.
     */
    TsSimpleAst.prototype.addSourceFiles = function () {
        var fileGlobs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fileGlobs[_i] = arguments[_i];
        }
        var filePaths = this.fileSystem.glob(fileGlobs);
        try {
            for (var filePaths_1 = __values(filePaths), filePaths_1_1 = filePaths_1.next(); !filePaths_1_1.done; filePaths_1_1 = filePaths_1.next()) {
                var filePath = filePaths_1_1.value;
                // ignore any FileNotFoundErrors
                try {
                    this.getOrAddSourceFile(filePath);
                }
                catch (ex) {
                    /* istanbul ignore if */
                    if (!(ex instanceof errors.FileNotFoundError))
                        throw ex;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (filePaths_1_1 && !filePaths_1_1.done && (_a = filePaths_1.return)) _a.call(filePaths_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var e_1, _a;
    };
    /**
     * Gets or adds a source file from a file path.
     * @param filePath - File path to create the file from.
     */
    TsSimpleAst.prototype.getOrAddSourceFile = function (filePath) {
        var absoluteFilePath = utils_1.FileUtils.getStandardizedAbsolutePath(filePath);
        if (!this.fileSystem.fileExistsSync(absoluteFilePath))
            throw new errors.FileNotFoundError(absoluteFilePath);
        return this.global.compilerFactory.getSourceFileFromFilePath(absoluteFilePath);
    };
    /**
     * Adds a source file from text.
     * @param filePath - File path for the source file.
     * @param sourceFileText - Source file text.
     * @throws - InvalidOperationError if a source file already exists at the provided file path.
     */
    TsSimpleAst.prototype.addSourceFileFromText = function (filePath, sourceFileText) {
        return this.global.compilerFactory.addSourceFileFromText(filePath, sourceFileText);
    };
    /**
     * Adds a source file from a structure.
     * @param filePath - File path for the source file.
     * @param structure - Structure that represents the source file.
     * @throws - InvalidOperationError if a source file already exists at the provided file path.
     */
    TsSimpleAst.prototype.addSourceFileFromStructure = function (filePath, structure) {
        var sourceFile = this.global.compilerFactory.addSourceFileFromText(filePath, "");
        sourceFile.fill(structure);
        return sourceFile;
    };
    /**
     * Removes a source file from the AST.
     * @param sourceFile - Source file to remove.
     * @returns True if removed.
     */
    TsSimpleAst.prototype.removeSourceFile = function (sourceFile) {
        return this.global.languageService.removeSourceFile(sourceFile);
    };
    TsSimpleAst.prototype.getSourceFileOrThrow = function (fileNameOrSearchFunction) {
        var sourceFile = this.getSourceFile(fileNameOrSearchFunction);
        if (sourceFile == null) {
            if (typeof fileNameOrSearchFunction === "string")
                throw new errors.InvalidOperationError("Could not find source file based on the provided name or path: " + fileNameOrSearchFunction + ".");
            else
                throw new errors.InvalidOperationError("Could not find source file based on the provided condition.");
        }
        return sourceFile;
    };
    TsSimpleAst.prototype.getSourceFile = function (fileNameOrSearchFunction) {
        var searchFunction = fileNameOrSearchFunction;
        if (typeof fileNameOrSearchFunction === "string")
            searchFunction = function (def) { return utils_1.FileUtils.filePathMatches(def.getFilePath(), fileNameOrSearchFunction); };
        return utils_1.ArrayUtils.find(this.getSourceFiles(), searchFunction);
    };
    /**
     * Gets all the source files contained in the compiler wrapper.
     * @param globPattern - Glob pattern for filtering out the source files.
     */
    TsSimpleAst.prototype.getSourceFiles = function (globPattern) {
        var sourceFiles = this.global.languageService.getSourceFiles();
        if (typeof globPattern === "string") {
            var mm_1 = new minimatch_1.Minimatch(globPattern, { matchBase: true });
            sourceFiles = sourceFiles.filter(function (s) { return mm_1.match(s.getFilePath()); });
        }
        return sourceFiles;
    };
    /**
     * Saves all the unsaved source files.
     */
    TsSimpleAst.prototype.saveUnsavedSourceFiles = function () {
        return Promise.all(this.getUnsavedSourceFiles().map(function (f) { return f.save(); }));
    };
    /**
     * Saves all the unsaved source files synchronously.
     *
     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.
     */
    TsSimpleAst.prototype.saveUnsavedSourceFilesSync = function () {
        try {
            // sidenote: I wish I could do something like in c# where I do this all asynchronously then
            // wait synchronously on the task. It would not be as bad as this is performance wise. Maybe there
            // is a way, but people just shouldn't be using this method unless they're really lazy.
            for (var _a = __values(this.getUnsavedSourceFiles()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var file = _b.value;
                file.saveSync();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var e_2, _c;
    };
    TsSimpleAst.prototype.getUnsavedSourceFiles = function () {
        return this.getSourceFiles().filter(function (f) { return !f.isSaved(); });
    };
    /**
     * Gets the compiler diagnostics.
     */
    TsSimpleAst.prototype.getDiagnostics = function () {
        var _this = this;
        // todo: implement cancellation token
        var compilerDiagnostics = ts.getPreEmitDiagnostics(this.global.program.compilerObject);
        return compilerDiagnostics.map(function (d) { return _this.global.compilerFactory.getDiagnostic(d); });
    };
    /**
     * Gets the language service.
     */
    TsSimpleAst.prototype.getLanguageService = function () {
        return this.global.languageService;
    };
    /**
     * Gets the program.
     */
    TsSimpleAst.prototype.getProgram = function () {
        return this.global.program;
    };
    /**
     * Gets the type checker.
     */
    TsSimpleAst.prototype.getTypeChecker = function () {
        return this.global.typeChecker;
    };
    /**
     * Emits all the source files.
     * @param emitOptions - Optional emit options.
     */
    TsSimpleAst.prototype.emit = function (emitOptions) {
        if (emitOptions === void 0) { emitOptions = {}; }
        return this.global.program.emit(emitOptions);
    };
    /**
     * Gets the compiler options.
     */
    TsSimpleAst.prototype.getCompilerOptions = function () {
        // return a copy
        return __assign({}, this.global.compilerOptions);
    };
    return TsSimpleAst;
}());
exports.TsSimpleAst = TsSimpleAst;
function getCompilerOptionsFromOptions(options, fileSystem) {
    return __assign({}, (options.tsConfigFilePath == null ? {} : utils_1.getCompilerOptionsFromTsConfig(options.tsConfigFilePath, fileSystem)), (options.compilerOptions || {}));
}

//# sourceMappingURL=TsSimpleAst.js.map
