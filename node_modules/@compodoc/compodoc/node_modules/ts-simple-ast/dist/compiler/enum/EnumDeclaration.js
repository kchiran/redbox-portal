"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values)/* istanbul ignore next */ || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var errors = require("./../../errors");
var manipulation_1 = require("./../../manipulation");
var utils_1 = require("./../../utils");
var callBaseFill_1 = require("./../callBaseFill");
var base_1 = require("./../base");
var common_1 = require("./../common");
var namespace_1 = require("./../namespace");
exports.EnumDeclarationBase = base_1.TextInsertableNode(namespace_1.NamespaceChildableNode(base_1.DocumentationableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(common_1.Node)))))));
var EnumDeclaration = /** @class */ (function (_super) {
    __extends(EnumDeclaration, _super);
    function EnumDeclaration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fills the node from a structure.
     * @param structure - Structure to fill.
     */
    EnumDeclaration.prototype.fill = function (structure) {
        callBaseFill_1.callBaseFill(exports.EnumDeclarationBase.prototype, this, structure);
        if (structure.isConst != null)
            this.setIsConstEnum(structure.isConst);
        if (structure.members != null && structure.members.length > 0)
            this.addMembers(structure.members);
        return this;
    };
    /**
     * Adds a member to the enum.
     * @param structure - Structure of the enum.
     */
    EnumDeclaration.prototype.addMember = function (structure) {
        return this.addMembers([structure])[0];
    };
    /**
     * Adds members to the enum.
     * @param structures - Structures of the enums.
     */
    EnumDeclaration.prototype.addMembers = function (structures) {
        return this.insertMembers(this.getMembers().length, structures);
    };
    /**
     * Inserts a member to the enum.
     * @param index - Index to insert at.
     * @param structure - Structure of the enum.
     */
    EnumDeclaration.prototype.insertMember = function (index, structure) {
        return this.insertMembers(index, [structure])[0];
    };
    /**
     * Inserts members to an enum.
     * @param index - Index to insert at.
     * @param structures - Structures of the enums.
     */
    EnumDeclaration.prototype.insertMembers = function (index, structures) {
        var members = this.getMembers();
        index = manipulation_1.verifyAndGetIndex(index, members.length);
        if (structures.length === 0)
            return [];
        var previousMember = members[index - 1];
        var previousMemberComma = previousMember == null ? undefined : previousMember.getNextSiblingIfKind(ts.SyntaxKind.CommaToken);
        var nextMember = members[index];
        var indentationText = this.getChildIndentationText();
        var newLineChar = this.global.manipulationSettings.getNewLineKind();
        var syntaxList = this.getChildSyntaxListOrThrow();
        var syntaxListChildren = syntaxList.getChildren();
        var insertChildIndex = previousMember == null ? 0 : syntaxListChildren.indexOf(previousMemberComma || previousMember) + 1;
        // create member code
        var numberChildren = 1;
        var code = "";
        if (previousMember != null && previousMemberComma == null) {
            code += ",";
            numberChildren++;
        }
        code += "" + newLineChar + getMemberText(structures[0]);
        try {
            for (var _a = __values(structures.slice(1)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var structure = _b.value;
                code += "," + newLineChar + getMemberText(structure);
                numberChildren += 2;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (nextMember != null) {
            code += ",";
            numberChildren++;
        }
        function getMemberText(structure) {
            var memberText = "" + indentationText + structure.name;
            if (typeof structure.value !== "undefined")
                memberText += " = " + structure.value;
            return memberText;
        }
        // get the insert position
        var insertPos;
        if (previousMember == null)
            insertPos = this.getFirstChildByKindOrThrow(ts.SyntaxKind.OpenBraceToken).getEnd();
        else if (previousMemberComma == null)
            insertPos = previousMember.getEnd();
        else
            insertPos = previousMember.getNextSiblingIfKind(ts.SyntaxKind.CommaToken).getEnd();
        // insert
        manipulation_1.insertIntoCreatableSyntaxList({
            parent: this,
            insertPos: insertPos,
            newText: code,
            syntaxList: syntaxList,
            childIndex: insertChildIndex,
            insertItemsCount: numberChildren
        });
        // get the members
        var newMembers = this.getMembers().slice(index, index + structures.length);
        newMembers.forEach(function (m, i) { return m.fill(structures[i]); });
        return newMembers;
        var e_1, _c;
    };
    EnumDeclaration.prototype.getMember = function (nameOrFindFunction) {
        return utils_1.getNamedNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);
    };
    EnumDeclaration.prototype.getMemberOrThrow = function (nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction("enum member", nameOrFindFunction); });
    };
    /**
     * Gets the enum's members.
     */
    EnumDeclaration.prototype.getMembers = function () {
        return this.getChildSyntaxListOrThrow().getChildren().filter(function (c) { return utils_1.TypeGuards.isEnumMember(c); });
    };
    /**
     * Toggle if it's a const enum
     */
    EnumDeclaration.prototype.setIsConstEnum = function (value) {
        return this.toggleModifier("const", value);
    };
    /**
     * Gets if it's a const enum.
     */
    EnumDeclaration.prototype.isConstEnum = function () {
        return this.getConstKeyword() != null;
    };
    /**
     * Gets the const enum keyword or undefined if not exists.
     */
    EnumDeclaration.prototype.getConstKeyword = function () {
        return this.getFirstModifierByKind(ts.SyntaxKind.ConstKeyword);
    };
    /**
     * Removes this enum declaration.
     */
    EnumDeclaration.prototype.remove = function () {
        manipulation_1.removeStatementedNodeChild(this);
    };
    return EnumDeclaration;
}(exports.EnumDeclarationBase));
exports.EnumDeclaration = EnumDeclaration;

//# sourceMappingURL=EnumDeclaration.js.map
