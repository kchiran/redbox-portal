"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var formatting_1 = require("./../formatting");
var textSeek_1 = require("./../textSeek");
var tree_1 = require("./../tree");
function removeChildrenWithFormattingFromCollapsibleSyntaxList(opts) {
    var children = opts.children;
    if (children.length === 0)
        return;
    var syntaxList = children[0].getParentSyntaxListOrThrow();
    if (syntaxList.getChildCount() === children.length) {
        removeChildrenWithFormatting({
            children: [syntaxList],
            getSiblingFormatting: function () { return formatting_1.FormattingKind.None; }
        });
    }
    else
        removeChildrenWithFormatting(opts);
}
exports.removeChildrenWithFormattingFromCollapsibleSyntaxList = removeChildrenWithFormattingFromCollapsibleSyntaxList;
function removeChildrenWithFormatting(opts) {
    var children = opts.children, getSiblingFormatting = opts.getSiblingFormatting;
    if (children.length === 0)
        return;
    var parent = children[0].getParentOrThrow();
    var sourceFile = parent.getSourceFile();
    var fullText = sourceFile.getFullText();
    var newLineKind = sourceFile.global.manipulationSettings.getNewLineKind();
    var previousSibling = children[0].getPreviousSibling();
    var nextSibling = children[children.length - 1].getNextSibling();
    var newText = getPrefix() + getSpacing() + getSuffix();
    var tempSourceFile = sourceFile.global.compilerFactory.createTempSourceFileFromText(newText, sourceFile.getFilePath());
    tree_1.replaceTreeWithChildIndex({
        replacementSourceFile: tempSourceFile,
        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),
        childIndex: children[0].getChildIndex(),
        childCount: -1 * children.length
    });
    function getPrefix() {
        return fullText.substring(0, getRemovalPos());
    }
    function getSpacing() {
        if (previousSibling != null && nextSibling != null) {
            var previousSiblingFormatting = getSiblingFormatting(parent, previousSibling);
            var nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
            if (previousSiblingFormatting === formatting_1.FormattingKind.Blankline || nextSiblingFormatting === formatting_1.FormattingKind.Blankline)
                return newLineKind + newLineKind;
            else if (previousSiblingFormatting === formatting_1.FormattingKind.Newline || nextSiblingFormatting === formatting_1.FormattingKind.Newline)
                return newLineKind;
            else if (previousSiblingFormatting === formatting_1.FormattingKind.Space || nextSiblingFormatting === formatting_1.FormattingKind.Space)
                return " ";
        }
        return "";
    }
    function getSuffix() {
        return fullText.substring(getRemovalEnd());
    }
    function getRemovalPos() {
        if (previousSibling != null && nextSibling != null)
            return previousSibling.getEnd();
        if (parent.getPos() === children[0].getPos())
            return children[0].getNonWhitespaceStart(); // do not shift the parent
        return children[0].isFirstNodeOnLine() ? textSeek_1.getPosAfterPreviousNonBlankLine(fullText, children[0].getNonWhitespaceStart()) : children[0].getNonWhitespaceStart();
    }
    function getRemovalEnd() {
        if (previousSibling != null && nextSibling != null) {
            var nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
            if (nextSiblingFormatting === formatting_1.FormattingKind.Blankline || nextSiblingFormatting === formatting_1.FormattingKind.Newline) {
                var nextSiblingStartLinePos = nextSibling.getStartLinePos();
                if (nextSiblingStartLinePos !== children[children.length - 1].getStartLinePos())
                    return nextSiblingStartLinePos;
            }
            return nextSibling.getStart();
        }
        if (parent.getEnd() === children[children.length - 1].getEnd())
            return children[children.length - 1].getEnd(); // do not shift the parent
        var nextNonSpaceOrTabChar = textSeek_1.getNextMatchingPos(fullText, children[children.length - 1].getEnd(), function (char) { return char !== " " && char !== "\t"; });
        if (fullText[nextNonSpaceOrTabChar] === "\r" || fullText[nextNonSpaceOrTabChar] === "\n")
            return textSeek_1.getPosAtNextNonBlankLine(fullText, nextNonSpaceOrTabChar);
        return nextNonSpaceOrTabChar;
    }
}
exports.removeChildrenWithFormatting = removeChildrenWithFormatting;

//# sourceMappingURL=removeChildrenWithFormatting.js.map
