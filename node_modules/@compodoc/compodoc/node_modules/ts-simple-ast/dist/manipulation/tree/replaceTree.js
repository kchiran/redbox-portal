"use strict";
var __read = (this && this.__read)/* istanbul ignore next */ || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread)/* istanbul ignore next */ || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var errors = require("./../../errors");
var nodeHandlers_1 = require("./nodeHandlers");
/**
 * Replaces with tree that creates a syntax list.
 */
function replaceTreeCreatingSyntaxList(opts) {
    var parent = opts.parent, replacementSourceFile = opts.replacementSourceFile, insertPos = opts.insertPos;
    replaceTree({
        parent: parent,
        childCount: 1,
        replacementSourceFile: replacementSourceFile,
        isFirstChild: function (currentNode, newNode) { return newNode.getKind() === ts.SyntaxKind.SyntaxList && insertPos <= newNode.getStart(); }
    });
}
exports.replaceTreeCreatingSyntaxList = replaceTreeCreatingSyntaxList;
/**
 * Replaces the tree based on the child index from the parent.
 */
function replaceTreeWithChildIndex(opts) {
    var replacementSourceFile = opts.replacementSourceFile, parent = opts.parent, childIndex = opts.childIndex, childCount = opts.childCount, replacingNodes = opts.replacingNodes;
    var parentChildren = parent.getChildren();
    errors.throwIfOutOfRange(childIndex, [0, parentChildren.length], "opts.childIndex");
    if (childCount < 0)
        errors.throwIfOutOfRange(childCount, [childIndex - parentChildren.length, 0], "opts.childCount");
    var i = 0;
    var isFirstChild = function () { return i++ === childIndex; };
    replaceTree({
        replacementSourceFile: replacementSourceFile,
        parent: parent,
        isFirstChild: isFirstChild,
        childCount: childCount,
        replacingNodes: replacingNodes
    });
}
exports.replaceTreeWithChildIndex = replaceTreeWithChildIndex;
/**
 * Replaces the tree based on the start and end position.
 */
function replaceTreeWithRange(opts) {
    var replacementSourceFile = opts.replacementSourceFile, changingParent = opts.parent, start = opts.start, end = opts.end;
    var sourceFile = changingParent.getSourceFile();
    var compilerFactory = sourceFile.global.compilerFactory;
    var parentHandler = new nodeHandlers_1.RangeParentHandler(compilerFactory, { start: start, end: end });
    if (changingParent === sourceFile)
        parentHandler.handleNode(sourceFile, replacementSourceFile);
    else {
        var parentFinderReplacement = new nodeHandlers_1.ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);
        parentFinderReplacement.handleNode(sourceFile, replacementSourceFile);
    }
}
exports.replaceTreeWithRange = replaceTreeWithRange;
/**
 * Replaces the tree with a new one.
 */
function replaceTree(opts) {
    var replacementSourceFile = opts.replacementSourceFile, changingParent = opts.parent, isFirstChild = opts.isFirstChild, childCount = opts.childCount;
    var sourceFile = changingParent.getSourceFile();
    var compilerFactory = sourceFile.global.compilerFactory;
    var replacingNodes = opts.replacingNodes == null ? undefined : __spread(opts.replacingNodes);
    var parentHandler = new nodeHandlers_1.DefaultParentHandler(compilerFactory, { childCount: childCount, isFirstChild: isFirstChild, replacingNodes: replacingNodes });
    if (changingParent === sourceFile)
        parentHandler.handleNode(sourceFile, replacementSourceFile);
    else {
        var parentFinderReplacement = new nodeHandlers_1.ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);
        parentFinderReplacement.handleNode(sourceFile, replacementSourceFile);
    }
}
exports.replaceTree = replaceTree;

//# sourceMappingURL=replaceTree.js.map
